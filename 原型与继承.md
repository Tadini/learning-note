### 原型链
js每个实例对象（object）都有一个私有属性(__proto__)指向它的构造函数的原型对象(prototype)。该原型对象也有一个自己的原型对象(__proto__),通过__proto__层层向上寻找直到找到一个对象的原型对象为null。根据定义null并没有原型，找到了null就是找到了原型链的最后一层。这种层层查找构成的串联就是原型链。
### 继承

实现一个继承 继承 属性继承 原型继承
```
function Person (name, age) {
	this.type = 'human';
	this.name = name;
	this.age = age;
	// 抽象工厂当前构造函数 不能被new实例化 只能继承
	if (new.target === Person) {
		throw new Error('当前函数不能被实例化');
	}
}

Person.prototype.eat = function (sth) {
	console.log(`我在吃${sth}`);
}

function Student (name, age, school = '') {
	Person.call(this);
	this.school = school
}
Student.prototype.learn = function (methods) {
	console.log(`学${methods}`);
}
// Student.prototype.__proto__ = Person.prototype;
Object.setPrototypeOf(Student.prototype, Person.prototype);

Student.prototype.play = function (sth) {
	console.log(`play${sth}`)
}

var s1 = new Student('xs1', 12, '小学1');
var s2 = new Student('xs2', 10, '小学3');

console.log(s1 instanceof Student, s1 instanceof Person); // true, true
console.log(s1.constructor === Student, s1.constructor === Person); // true false
console.log(s2 instanceof Student, s2 instanceof Person);// true true
console.log(s2.constructor === Student, s2.constructor === Person); // true false

s1.eat('饺子'); // 我在吃饺子
s2.eat('包子'); // 我在吃包子

s1.play('篮球'); // play篮球
s1.learn('画画'); // 学画画
s2.play('足球'); // play足球

var p1 = new Person('人类', 100); // 报错 Uncaught Error: 当前函数不能被实例化


```

#### 如何实现Object.setPrototypeOf 两种方式
```
/** 方式1：
 * @params {obj} 要重新设置原型的对象
 * @params {proto} 该对象的新原型 （一个对象或者null）
*/
function setPrototypeOf (obj, proto) {
	obj.__proto__ = proto;
	return obj
}
// 调用更改子类原型
setPrototypeOf(Student.prototype, Person.prototype);
/** 方式2：
 * @params {obj} 要重新设置原型的对象
 * @params {proto} 该对象的新原型 （一个对象或者null）
*/
function entends (obj, constructor) {
	var F = function () {};
	F.prototype = obj.prototype;
	var instance = new F;
	instance.constructor = constructor;
	return instance;
}

```

